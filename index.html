<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CHORUS AI: Strategist's Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
            overflow: hidden;
        }
        #appContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .toolbar {
            flex-shrink: 0;
        }
        #mainContent {
            position: relative;
            flex-grow: 1;
            overflow: hidden;
        }
        #noteCanvasContainer {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #e9e9e9;
            cursor: grab;
            touch-action: none;
        }
        #noteCanvasContainer:focus { outline: none; }
        #noteCanvasContainer.panning { cursor: grabbing; }
        #transformContainer {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
        }
        #noteCanvas {
            width: 4000px;
            height: 3000px;
            position: relative;
            background-image:
                linear-gradient(to right, #d0d0d0 1px, transparent 1px),
                linear-gradient(to bottom, #d0d0d0 1px, transparent 1px);
            background-size: 20px 20px;
            background-color: #fdfdfd;
        }
        #svgCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .chorus-chunk {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-width: 200px;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            overflow: visible;
            transition: border-color 0.2s, outline 0.2s, opacity 0.3s, transform 0.3s;
            z-index: 1;
        }
        .chorus-chunk.hidden-by-layer {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.9);
        }
        .chorus-chunk.selected-chunk { border-color: #2563eb; border-width: 2px; }
        .chorus-chunk.linking-source-chunk { outline: 2px solid #16a34a; border-color: #16a34a; }
        .chunk-header {
            background-color: #f0f0f0;
            padding: 6px 10px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: move;
            border-bottom: 1px solid #ccc;
            user-select: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            justify-content: space-between;
            align-items: center;
            touch-action: none;
        }
        .chunk-header-title .tag { font-weight: 600; }
        .chunk-header .shape-symbol, .chunk-header .color-symbol { font-weight: normal; }
        .chunk-actions { display: flex; align-items: center; }
        .chunk-action-btn { background: none; border: none; cursor: pointer; padding: 2px; margin-left: 4px; line-height: 1; }
        .chunk-action-btn svg { width: 14px; height: 14px; stroke: #555; stroke-width: 2; }
        .chunk-action-btn:hover svg { stroke: #333; }
        .delete-chunk-btn:hover svg { stroke: #d00; }
        .ai-chunk-btn:hover svg { stroke: #8b5cf6; }
        .link-chunk-btn.linking-active svg { stroke: #16a34a !important; }
        .chunk-content { flex-grow: 1; padding: 12px; font-size: 0.9rem; overflow-y: auto; outline: none; }
        .resize-handle { width: 16px; height: 16px; background-color: #bbb; position: absolute; right: -4px; bottom: -4px; cursor: se-resize; border-top-left-radius: 4px; z-index: 10; touch-action: none; }
        .connecting-line { stroke: #3b82f6; stroke-width: 2; fill: none; transition: opacity 0.3s; }
        .connecting-line.hidden-by-layer { opacity: 0; }
        .arrow-head { fill: #3b82f6; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 10000; }
        .modal-content { background-color: white; padding: 24px; border-radius: 8px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); width: 90%; max-width: 500px; }
        .modal-content.max-w-3xl { max-width: 800px; }
        .form-input, .form-textarea, .form-select { width: 100%; padding: 8px 12px; border: 1px solid #ccc; border-radius: 6px; margin-bottom: 12px; background-color: white; }
        .form-textarea { min-height: 120px; resize: vertical; }
        .btn { padding: 8px 12px; border-radius: 6px; font-weight: 500; cursor: pointer; transition: background-color 0.2s, color 0.2s, opacity 0.2s; margin-right: 8px; border: none; display: inline-flex; align-items: center; justify-content: center; white-space: nowrap; }
        .btn svg.icon { width: 18px; height: 18px; margin-right: 6px; }
        .btn svg.spinner { width: 18px; height: 18px; margin:auto; }
        .btn.loading { opacity: 0.7; cursor: not-allowed; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background-color: #2563eb; color: white; }
        .btn-primary:hover:not(:disabled):not(.loading) { background-color: #1d4ed8; }
        .btn-secondary { background-color: #e5e7eb; color: #374151; }
        .btn-secondary:hover:not(:disabled):not(.loading) { background-color: #d1d5db; }
        .btn-danger { background-color: #dc2626; color: white; }
        .btn-danger:hover:not(:disabled):not(.loading) { background-color: #b91c1c; }
        .btn-donate { background-color: #ec4899; color: white; }
        .btn-donate:hover:not(:disabled):not(.loading) { background-color: #db2777; }
        #helpModal .modal-content, #messageModal .modal-content, #unlinkModal .modal-content { display: flex; flex-direction: column; max-height: 80vh; }
        #messageText, #help-scroll-content, #unlinkList { max-height: 60vh; overflow-y: auto; padding-right: 1rem;}
        body.linking-mode { cursor: crosshair; }
        body.linking-mode .chorus-chunk:not(.linking-source-chunk):not(.hidden-by-layer):hover { outline: 2px dashed #2563eb; }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; line-height: 1; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        .help-section { border-bottom: 1px solid #e5e7eb; padding-bottom: 12px; margin-bottom: 12px; }
        .help-section:last-child { border-bottom: none; }
        .help-section h3 { font-size: 1.1rem; font-weight: 600; margin-bottom: 8px; }
        .help-section ul { list-style-type: disc; margin-left: 20px; }
        .help-section li { margin-bottom: 6px; }
        .help-section code { background-color: #f3f4f6; padding: 2px 4px; border-radius: 4px; font-size: 0.85em; }

        /* Dropdowns */
        .dropdown { position: relative; display: inline-block; }
        .dropdown-content { 
            display: none; 
            position: absolute; 
            background-color: #f9f9f9; 
            min-width: 160px; 
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); 
            z-index: 100; 
            right: 0; 
            border-radius: 6px; 
            padding: 4px; 
        }
        .dropdown-content button { display: block; width: 100%; text-align: left; padding: 8px 12px; }
        .dropdown-content.show { 
            display: block; 
        }
        #layerControl {min-width: 220px;}
        #layerControl label { display: block; padding: 8px 12px; cursor: pointer; border-radius: 4px; }
        #layerControl label:hover { background-color: #f1f1f1; }
        #layerControl input { margin-right: 10px; }

        @media (max-width: 640px) {
            #layerControl {
                right: auto;
                left: 50%;
                transform: translateX(-50%);
            }
        }

        /* Timeline View */
        #timelineView { display: none; padding: 2rem; overflow-y: auto; height: 100%; }
        .timeline-item { position: relative; padding: 1rem 1rem 1rem 2.5rem; border-left: 3px solid #d1d5db; margin-bottom: 1rem; transition: margin-left 0.3s ease-in-out; }
        .timeline-item:last-child { border-left: 3px solid transparent; }
        .timeline-dot { position: absolute; left: -9px; top: calc(1rem + 4px); width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; }
        .timeline-content { background-color: white; padding: 1rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .timeline-header { font-weight: 600; font-size: 1.1em; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.5rem; margin-bottom: 0.5rem; }
        .timeline-meta { font-size: 0.8rem; color: #6b7280; margin-bottom: 0.5rem; }

    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div id="appContainer">
        <!-- Toolbar -->
        <div class="toolbar p-3 bg-white shadow-md flex flex-wrap items-center justify-center sm:justify-between gap-2 print:hidden">
            <!-- Group 1 -->
            <div class="flex items-center flex-wrap justify-center gap-2">
                <button id="addChunkBtn" class="btn btn-primary" title="Add Chunk (A)">Add</button>
                <button id="templatesBtn" class="btn btn-secondary" title="Load a strategic template">Templates</button>
                <button id="clearCanvasBtn" class="btn btn-danger" title="Clear Canvas">Clear</button>
                <button id="undoDeleteBtn" class="btn btn-secondary" title="Undo Last Delete (Ctrl/Cmd+Z)" disabled>Undo</button>
            </div>

            <!-- Group 2 -->
            <div class="flex items-center flex-wrap justify-center gap-2">
                 <button id="summarizeBtn" class="btn btn-secondary" title="Summarize the board with AI"><svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.25 10.5l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5ZM16.5 3.75l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5Z"></path></svg>Summarize</button>
                 <button id="viewToggleBtn" class="btn btn-secondary" title="Toggle Canvas/Timeline View">Timeline</button>
                 <div class="dropdown">
                    <button class="btn btn-secondary">Layers</button>
                    <div id="layerControl" class="dropdown-content"></div>
                </div>
                <button id="zoomOutBtn" class="btn btn-secondary" title="Zoom Out (-)">-</button>
                <button id="zoomResetBtn" class="btn btn-secondary" title="Reset Zoom (0)">100%</button>
                <button id="zoomInBtn" class="btn btn-secondary" title="Zoom In (+/=)">+</button>
            </div>

            <!-- Group 3 -->
            <div class="flex items-center flex-wrap justify-center gap-2">
                <span id="chunkCountDisplay" class="text-sm text-gray-500 mx-2">Chunks: 0</span>
                 <div class="dropdown">
                    <button class="btn btn-secondary">Export</button>
                    <div class="dropdown-content">
                        <button id="exportTxtBtn" class="btn btn-secondary w-full">TXT</button>
                        <button id="exportMdBtn" class="btn btn-secondary w-full">Markdown</button>
                        <button id="exportHtmlBtn" class="btn btn-secondary w-full">HTML</button>
                    </div>
                </div>
                <button id="saveBtn" class="btn btn-secondary" title="Save to File (Ctrl/Cmd+S)">Save</button>
                <button id="loadBtn" class="btn btn-secondary" title="Load from File (Ctrl/Cmd+O)">Load</button>
                <button id="settingsBtn" class="btn btn-secondary" title="Settings">Settings</button>
                <button id="helpBtn" class="btn btn-secondary" title="Help (?)">Help</button>
                <button id="donateBtn" class="btn btn-donate" title="Support the developer">
                    <svg class="icon" style="width: 16px; height: 16px; margin-right: 4px;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd" />
                    </svg>
                    Donate
                </button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div id="mainContent">
            <div id="noteCanvasContainer" tabindex="-1">
                <div id="transformContainer">
                    <div id="noteCanvas">
                        <svg id="svgCanvas"></svg>
                    </div>
                </div>
            </div>
            <div id="timelineView"></div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="text-center p-2 text-xs text-gray-500 print:hidden">
        &copy; <span id="copyrightYear"></span> Thorsten Becker. Strategist's Edition.
        <a href="https://www.linkedin.com/in/thorsten-becker-de/" target="_blank" class="text-blue-600 hover:underline">Connect on LinkedIn</a>.
    </footer>

    <!-- Modals -->
    <div id="addChunkModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2>Add New Chunk</h2>
            <label for="chunkTypeSelect" class="block mb-1 font-medium">Chunk Type:</label>
            <select id="chunkTypeSelect" class="form-select"></select>
            <label for="chunkShapeSelect" class="block mb-1 mt-3 font-medium">Shape:</label>
            <select id="chunkShapeSelect" class="form-select"></select>
            <label for="chunkColorSelect" class="block mb-1 mt-3 font-medium">Color Tag / Layer:</label>
            <select id="chunkColorSelect" class="form-select"></select>
            <div class="mt-6 flex justify-end">
                <button id="cancelAddChunkBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmAddChunkBtn" class="btn btn-primary">Add Chunk</button>
            </div>
        </div>
    </div>
    <div id="editChunkModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2>Edit Chunk</h2>
            <input type="hidden" id="editingChunkId">
            <label for="editChunkTypeSelect" class="block mb-1 font-medium">Chunk Type:</label>
            <select id="editChunkTypeSelect" class="form-select"></select>
            <label for="editChunkShapeSelect" class="block mb-1 mt-3 font-medium">Shape:</label>
            <select id="editChunkShapeSelect" class="form-select"></select>
            <label for="editChunkColorSelect" class="block mb-1 mt-3 font-medium">Color Tag / Layer:</label>
            <select id="editChunkColorSelect" class="form-select"></select>
            <div class="mt-6 flex justify-end">
                <button id="cancelEditChunkBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmEditChunkBtn" class="btn btn-primary">Save Changes</button>
            </div>
        </div>
    </div>
    <div id="unlinkModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2>Manage Links</h2>
            <p class="text-sm text-gray-600 mb-4">Remove outgoing links from this chunk.</p>
            <div id="unlinkList" class="space-y-2"></div>
            <div class="mt-6 flex justify-end">
                <button id="closeUnlinkModalBtn" class="btn btn-primary">Done</button>
            </div>
        </div>
    </div>
    <div id="templatesModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2>Load a Strategic Template</h2>
            <p class="text-sm text-gray-600 mb-4">Loading a template will clear the current canvas.</p>
            <div id="templateList" class="space-y-2"></div>
        </div>
    </div>
    <div id="settingsModal" class="modal hidden">
        <div class="modal-content max-w-3xl">
            <span id="closeSettingsModalBtn" class="close-button">&times;</span>
            <h2>Settings</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mt-4">
                <div>
                    <h3 class="font-semibold text-lg mb-2">API Key</h3>
                    <label for="geminiApiKeyInput" class="block mb-1 font-medium">Google AI API Key</label>
                    <p class="text-xs text-gray-500 mb-2">Required for AI features. Your key is saved only in this browser's local storage.</p>
                    <input type="password" id="geminiApiKeyInput" class="form-input" placeholder="Enter your API key here">
                    <p class="text-xs text-gray-500 mb-4">Get a key from <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-600 hover:underline">Google AI Studio</a>.</p>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-2">Chunk Type Manager</h3>
                    <div id="customTypesContainer" class="space-y-2 max-h-48 overflow-y-auto border p-2 rounded-md bg-gray-50"></div>
                    <form id="addCustomTypeForm" class="flex gap-2 mt-2">
                        <input type="text" id="customTypeTag" placeholder="#new-type" class="form-input mb-0">
                        <input type="text" id="customTypeDesc" placeholder="Description" class="form-input mb-0 flex-grow">
                        <button type="submit" class="btn btn-primary whitespace-nowrap !m-0">Add Type</button>
                    </form>
                </div>
            </div>
             <div class="mt-6 flex justify-end">
                <button id="cancelSettingsBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveSettingsBtn" class="btn btn-primary">Save Settings</button>
            </div>
        </div>
    </div>
    <div id="aiActionModal" class="modal hidden">
        <div class="modal-content">
             <span id="closeAiActionModalBtn" class="close-button">&times;</span>
            <h2 class="flex items-center">AI Assistant</h2>
            <p class="text-sm text-gray-600 mb-4">Powered by Gemini. Current chunk content will be used as context.</p>
            <label for="aiPromptTextarea" class="block mb-1 mt-3 font-medium">Your Prompt:</label>
            <textarea id="aiPromptTextarea" class="form-textarea" placeholder="e.g., 'Critique this plan and identify its three main weaknesses.'"></textarea>
            <div class="mt-4 flex flex-wrap justify-between items-center gap-2">
                <button id="aiActionSuggestNextBtn" class="btn btn-secondary">Suggest Next</button>
                <div class="flex-grow"></div>
                <button id="cancelAiActionBtn" class="btn btn-secondary">Cancel</button>
                <button id="aiActionGenerateBtn" class="btn btn-primary">Generate & Replace</button>
            </div>
        </div>
    </div>
    <div id="helpModal" class="modal hidden">
        <div class="modal-content">
            <span id="closeHelpModalSpan" class="close-button">&times;</span>
            <h2>CHORUS Quick Help</h2>
            <div id="help-scroll-content">
                <div class="help-section">
                    <h3>What is CHORUS Strategist's Edition?</h3>
                    <p class="mb-2">This is a specialized version of the CHORUS thinking tool, adapted for strategic planning, wargaming, and competitive analysis. It replaces abstract concepts with a practical vocabulary for strategists, allowing you to map out complex operational environments.</p>
                    <p>Use it to visualize plans, analyze threats and opportunities, track resources, and simulate courses of action. The goal is to move beyond linear plans and embrace the dynamic, interconnected nature of strategy.</p>
                </div>
                <div class="help-section">
                    <h3>✨ New in this Edition</h3>
                    <ul>
                        <li><strong>Multiple Connections:</strong> A chunk can now link to multiple other chunks. Clicking the unlink icon on a chunk with links will open a menu to manage them individually.</li>
                        <li><strong>Strategic Templates:</strong> Instantly load frameworks like SWOT, OODA Loop, or Course of Action (COA) Development from the 'Templates' button to kickstart your analysis.</li>
                        <li><strong>Layer Control:</strong> Use the 'Layers' dropdown to show or hide chunks based on their color tag. This is crucial for managing complexity and focusing on specific aspects of your plan (e.g., view only Friendly Assets or filter out all Support chunks).</li>
                        <li><strong>Timeline View:</strong> Switch to a chronological 'Timeline View' to see your plan unfold sequentially. This view organizes chunks from top-to-bottom, perfect for reviewing phased operations or after-action reports.</li>
                        <li><strong>Custom Chunk Types:</strong> Define your own strategic vocabulary in the Settings modal. If you need a `#PhaseLine` or `#EconomicFactor` chunk, you can create it yourself.</li>
                        <li><strong>Strategic Vocabulary:</strong> Chunk Types and Shapes have been updated with military and strategic planning in mind (e.g., `#objective`, `#threat`, `⚔` for conflict).</li>
                    </ul>
                </div>
                <div class="help-section"><h3>Keyboard Shortcuts</h3><ul id="shortcutsList"></ul></div>
                <div class="help-section"><h3>Chunk Types</h3><ul id="helpCoreChunks"></ul></div>
                <div class="help-section"><h3>Shapes (Visual Identifiers)</h3><ul id="helpShapes"></ul></div>
                <div class="help-section"><h3>Color Tags / Layers</h3><ul id="helpColors"></ul></div>
                <div class="help-section">
                    <h3>Support the Developer</h3>
                    <p>If you find this app helpful, please consider supporting my work by donating. It helps me dedicate more time to improving it and creating new tools.</p>
                    <p class="mt-2">
                        <a href="https://ko-fi.com/thorstenbecker" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline font-semibold">
                           Donate via Ko-fi
                        </a>
                    </p>
                </div>
            </div>
            <div class="mt-6 flex justify-end"><button id="closeHelpBtn" class="btn btn-primary">OK</button></div>
        </div>
    </div>
    <div id="messageModal" class="modal hidden">
        <div class="modal-content max-w-lg">
            <h2 id="messageTitle" class="text-xl font-semibold mb-3">Message</h2>
            <div id="messageText" class="mb-4 text-sm"></div>
            <div id="messageButtons" class="flex justify-end"></div>
        </div>
    </div>
    <input type="file" id="fileLoadInput" class="hidden" accept=".json,application/json">

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Constants & Definitions ---
        const DEFAULT_CHUNK_TYPES = {
            core: [ { tag: "#objective", description: "The primary goal or commander's intent" }, { tag: "#asset", description: "A friendly unit, resource, or capability" }, { tag: "#threat", description: "An enemy unit, risk, or obstacle" }, { tag: "#intel", description: "A piece of intelligence or data point" }, { tag: "#action", description: "A planned action or course of action (COA)" }, { tag: "#decision", description: "A key decision point or go/no-go gate" }, { tag: "#assumption", description: "An assumption the plan is based on" } ],
            secondary: [ { tag: "#support", description: "Logistics, supporting effort, or details" }, { tag: "#comms", description: "Communication plan or note" }, { tag: "#contingency", description: "A backup plan or 'what if' scenario" }, { tag: "#feedback", description: "A feedback loop or consequence of an action" }, { tag: "#debrief", description: "Conclusion, lesson learned, after-action report" } ],
        };
        const SHAPES = [ { name: "Circle", symbol: "◯", meaning: "Core, self, central focus" }, { name: "Square", symbol: "▢", meaning: "Structure, foundation, argument" }, { name: "Triangle", symbol: "△", meaning: "Change, direction, movement" }, { name: "Diamond", symbol: "◇", meaning: "Insight, key moment, crystallization" }, { name: "Target", symbol: "◎", meaning: "Objective, Goal, Target" }, { name: "Flag", symbol: "⚐", meaning: "Key Location, Control Point, Asset" }, { name: "Shield", symbol: "⛨", meaning: "Defense, Security, Protection" }, { name: "Bolt", symbol: "⚡", meaning: "Action, Attack, High Impact Event" }, { name: "Skull", symbol: "☠", meaning: "Threat, Danger, Critical Risk" }, { name: "Eye", symbol: "👁", meaning: "Intelligence, Observation, Recon" }, { name: "Crossed Swords", symbol: "⚔", meaning: "Conflict, Battle, Opposition" }, { name: "Question Mark", symbol: "?", meaning: "Unknown, Assumption, Information Gap" }, ];
        const COLORS = [ { name: "Red", symbol: "🔴", essence: "Threat, Urgency, Stop", tailwindClass: "text-red-500" }, { name: "Blue", symbol: "🔵", essence: "Friendly, Asset, Go", tailwindClass: "text-blue-500" }, { name: "Green", symbol: "🟢", essence: "Opportunity, Growth, Go", tailwindClass: "text-green-500" }, { name: "Yellow", symbol: "🟡", essence: "Uncertain, Caution, Neutral", tailwindClass: "text-yellow-400" }, { name: "Purple", symbol: "🟣", essence: "Intel, Command, Key Insight", tailwindClass: "text-purple-500" }, { name: "Grey", symbol: "🩶", essence: "Support, Neutral, Background", tailwindClass: "text-gray-500" }, { name: "Black", symbol: "⚫", essence: "Finality, Obstacle, Fact", tailwindClass: "text-black" }, { name: "White", symbol: "⚪", essence: "Assumption, Blank Slate", tailwindClass: "text-gray-300" } ];
        const ICON_PENCIL_EDIT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg>`;
        const ICON_LINK = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" /></svg>`;
        const ICON_UNLINK = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244m-9.951-2.206a4.5 4.5 0 006.364-6.364L9.65 3.65m-3.069 3.069L3.5 9.787m0 0L1.454 7.742M3.5 9.787l2.046 2.046M3 3l18 18" /></svg>`;
        const ICON_LINKING_ACTIVE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="animate-pulse"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" /></svg>`;
        const ICON_DELETE = `<svg xmlns="http="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" /></svg>`;
        const ICON_AI_SPARKLE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.25 10.5l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5ZM16.5 3.75l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5Z" /></svg>`;

        // --- DOM Elements Cache ---
        const noteCanvasContainer = document.getElementById('noteCanvasContainer'); const mainContent = document.getElementById('mainContent'); const timelineView = document.getElementById('timelineView'); const viewToggleBtn = document.getElementById('viewToggleBtn'); const transformContainer = document.getElementById('transformContainer'); const svgCanvas = document.getElementById('svgCanvas'); const noteCanvas = document.getElementById('noteCanvas'); const addChunkBtn = document.getElementById('addChunkBtn'); const templatesBtn = document.getElementById('templatesBtn'); const templatesModal = document.getElementById('templatesModal'); const templateList = document.getElementById('templateList'); const layerControl = document.getElementById('layerControl'); const clearCanvasBtn = document.getElementById('clearCanvasBtn'); const undoDeleteBtn = document.getElementById('undoDeleteBtn'); const chunkCountDisplay = document.getElementById('chunkCountDisplay'); const zoomInBtn = document.getElementById('zoomInBtn'); const zoomOutBtn = document.getElementById('zoomOutBtn'); const zoomResetBtn = document.getElementById('zoomResetBtn'); const addChunkModal = document.getElementById('addChunkModal'); const chunkTypeSelect = document.getElementById('chunkTypeSelect'); const chunkShapeSelect = document.getElementById('chunkShapeSelect'); const chunkColorSelect = document.getElementById('chunkColorSelect'); const confirmAddChunkBtn = document.getElementById('confirmAddChunkBtn'); const cancelAddChunkBtn = document.getElementById('cancelAddChunkBtn'); const editChunkModal = document.getElementById('editChunkModal'); const editingChunkIdInput = document.getElementById('editingChunkId'); const editChunkTypeSelect = document.getElementById('editChunkTypeSelect'); const editChunkShapeSelect = document.getElementById('editChunkShapeSelect'); const editChunkColorSelect = document.getElementById('editChunkColorSelect'); const confirmEditChunkBtn = document.getElementById('confirmEditChunkBtn'); const cancelEditChunkBtn = document.getElementById('cancelEditChunkBtn'); const summarizeBtn = document.getElementById('summarizeBtn'); const settingsBtn = document.getElementById('settingsBtn'); const settingsModal = document.getElementById('settingsModal'); const geminiApiKeyInput = document.getElementById('geminiApiKeyInput'); const saveSettingsBtn = document.getElementById('saveSettingsBtn'); const cancelSettingsBtn = document.getElementById('cancelSettingsBtn'); const customTypesContainer = document.getElementById('customTypesContainer'); const addCustomTypeForm = document.getElementById('addCustomTypeForm'); const customTypeTagInput = document.getElementById('customTypeTag'); const customTypeDescInput = document.getElementById('customTypeDesc'); const aiActionModal = document.getElementById('aiActionModal'); const aiPromptTextarea = document.getElementById('aiPromptTextarea'); const aiActionGenerateBtn = document.getElementById('aiActionGenerateBtn'); const aiActionSuggestNextBtn = document.getElementById('aiActionSuggestNextBtn'); const cancelAiActionBtn = document.getElementById('cancelAiActionBtn'); const closeAiActionModalBtn = document.getElementById('closeAiActionModalBtn'); const closeSettingsModalBtn = document.getElementById('closeSettingsModalBtn'); const helpBtn = document.getElementById('helpBtn'); const helpModal = document.getElementById('helpModal'); const closeHelpBtn = document.getElementById('closeHelpBtn'); const closeHelpModalSpan = document.getElementById('closeHelpModalSpan'); const saveBtn = document.getElementById('saveBtn'); const loadBtn = document.getElementById('loadBtn'); const fileLoadInput = document.getElementById('fileLoadInput'); const messageModal = document.getElementById('messageModal'); const messageTitle = document.getElementById('messageTitle'); const messageText = document.getElementById('messageText'); const messageButtons = document.getElementById('messageButtons');
        const unlinkModal = document.getElementById('unlinkModal');
        const unlinkList = document.getElementById('unlinkList');
        const closeUnlinkModalBtn = document.getElementById('closeUnlinkModalBtn');
        const exportTxtBtn = document.getElementById('exportTxtBtn');
        const exportMdBtn = document.getElementById('exportMdBtn');
        const exportHtmlBtn = document.getElementById('exportHtmlBtn');
        const donateBtn = document.getElementById('donateBtn');

        // --- App State ---
        let currentView = 'canvas'; let chunkTypes = {}; let allChunkTypesList = []; let layerVisibility = {}; let chunks = []; let chunksMap = new Map();
        let highestZIndex = 1; let draggedChunk = null; let resizingChunk = null; let interactionStartX = 0; let interactionStartY = 0; let offsetX = 0; let offsetY = 0; let startX = 0; let startY = 0; let startWidth = 0; let startHeight = 0; let selectedChunkId = null; let linkingMode = false; let linkingSourceChunkId = null; let lastDeletedChunk = null; let geminiApiKey = null; let activeAiChunkId = null;
        let scale = 1; let translateX = 0; let translateY = 0; const MIN_SCALE = 0.1; const MAX_SCALE = 3.0; const ZOOM_SENSITIVITY = 0.001;
        let currentAction = null; let panStartX = 0; let panStartY = 0; let initialPinchDistance = null; let transformUpdateQueued = false;

        // --- Strategic Templates Definition ---
        const STRATEGIC_TEMPLATES = {
            swot: { name: "SWOT Analysis", description: "Analyze Strengths, Weaknesses, Opportunities, and Threats.", chunks: [ { x: 100, y: 100, w: 250, h: 150, type: "#asset", shape: "Shield", color: "Blue", text: "Strengths" }, { x: 400, y: 100, w: 250, h: 150, type: "#threat", shape: "Skull", color: "Red", text: "Weaknesses" }, { x: 100, y: 300, w: 250, h: 150, type: "#asset", shape: "Flag", color: "Green", text: "Opportunities" }, { x: 400, y: 300, w: 250, h: 150, type: "#threat", shape: "Crossed Swords", color: "Red", text: "Threats" } ], links: [] },
            ooda: { name: "OODA Loop", description: "A cycle for decision making: Observe, Orient, Decide, Act.", chunks: [ { id: "o1", x: 350, y: 100, w: 250, h: 120, type: "#intel", shape: "Eye", color: "Purple", text: "Observe" }, { id: "o2", x: 650, y: 300, w: 250, h: 120, type: "#decision", shape: "Triangle", color: "Yellow", text: "Orient" }, { id: "o3", x: 350, y: 500, w: 250, h: 120, type: "#decision", shape: "Diamond", color: "Blue", text: "Decide" }, { id: "o4", x: 50,  y: 300, w: 250, h: 120, type: "#action", shape: "Bolt", color: "Red", text: "Act" } ], links: [{ from: "o1", to: "o2" }, { from: "o2", to: "o3" }, { from: "o3", to: "o4" }, { from: "o4", to: "o1" }] },
            coa: { name: "COA Development", description: "Develop and compare multiple Courses of Action.", chunks: [ { id: "c1", x: 500, y: 100, w: 300, h: 120, type: "#objective", shape: "Target", color: "Purple", text: "Primary Objective" }, { id: "c2", x: 200, y: 300, w: 280, h: 150, type: "#action", shape: "Square", color: "Blue", text: "Course of Action 1" }, { id: "c3", x: 200, y: 500, w: 280, h: 150, type: "#support", shape: "Square", color: "Blue", text: "Pros & Cons for COA 1" }, { id: "c4", x: 800, y: 300, w: 280, h: 150, type: "#action", shape: "Square", color: "Yellow", text: "Course of Action 2" }, { id: "c5", x: 800, y: 500, w: 280, h: 150, type: "#support", shape: "Square", color: "Yellow", text: "Pros & Cons for COA 2" } ], links: [{ from: "c1", to: "c2" }, { from: "c2", to: "c3" }, { from: "c1", to: "c4" }, { from: "c4", to: "c5" }] }
        };

        // --- Utility & Setup Functions ---
        function generateId() { return 'chunk-' + Date.now() + '-' + Math.random().toString(36).substring(2, 9); }
        function showModal(modalElement) { modalElement.classList.remove('hidden'); }
        function hideModal(modalElement) { modalElement.classList.add('hidden'); }
        function showMessage(title, text, buttonsConfig = [{ text: 'OK', class: 'btn-primary', action: () => hideModal(messageModal) }]) {
            messageTitle.textContent = title; messageText.innerHTML = text; messageButtons.innerHTML = '';
            buttonsConfig.forEach(btnConfig => {
                const button = document.createElement('button');
                button.className = `btn ${btnConfig.class || 'btn-secondary'}`; button.textContent = btnConfig.text;
                button.onclick = () => { if (btnConfig.action) btnConfig.action(); if (!btnConfig.noHide) hideModal(messageModal); };
                messageButtons.appendChild(button);
            });
            showModal(messageModal);
        }
        function updateChunkCounter() { chunkCountDisplay.textContent = `Chunks: ${chunks.length}`; }

        function populateSelectWithOptions(selectElement, optionsArray, currentValue, groups = null, groupLabelFormatterFn = null) {
            selectElement.innerHTML = '';
            if (groups && groupLabelFormatterFn) {
                 for (const groupKey in groups) {
                    if (groups.hasOwnProperty(groupKey) && groups[groupKey].length > 0) {
                        const groupItems = groups[groupKey];
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = groupLabelFormatterFn(groupKey);
                        groupItems.forEach(item => {
                            const option = document.createElement('option');
                            option.value = item.tag; option.textContent = `${item.tag} - ${item.description}`;
                            if (item.tag === currentValue) option.selected = true;
                            optgroup.appendChild(option);
                        });
                        selectElement.appendChild(optgroup);
                    }
                }
            } else if (optionsArray) {
                optionsArray.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.value; option.textContent = opt.text;
                    if (opt.value === currentValue) option.selected = true;
                    selectElement.appendChild(option);
                });
            }
        }

        function populateHelpModal() {
            document.getElementById('shortcutsList').innerHTML = `
                <li><code>Ctrl/Cmd + S</code>: Save</li>
                <li><code>Ctrl/Cmd + O</code>: Load</li>
                <li><code>Ctrl/Cmd + Z</code>: Undo Delete</li>
                <li><code>A</code>: Add a new chunk</li>
                <li><code>Esc</code>: Close modals / Deselect</li>
                <li><code>Delete</code> / <code>Backspace</code>: Delete selected</li>`;
            document.getElementById('helpCoreChunks').innerHTML = allChunkTypesList.map(c => `<li><code>${c.tag}</code>: ${c.description}</li>`).join('');
            document.getElementById('helpShapes').innerHTML = SHAPES.map(s => `<li><strong>${s.symbol} ${s.name}</strong>: ${s.meaning}</li>`).join('');
            document.getElementById('helpColors').innerHTML = COLORS.map(c => `<li><span class="${c.tailwindClass}">${c.symbol}</span> <strong>${c.name}</strong>: ${c.essence}</li>`).join('');
        }

        function populateAddChunkModal() { 
            populateSelectWithOptions(chunkTypeSelect, null, null, chunkTypes, key => key.charAt(0).toUpperCase() + key.slice(1) + " Types"); 
            populateSelectWithOptions(chunkShapeSelect, SHAPES.map(s => ({value: s.name, text: `${s.symbol} ${s.name} - ${s.meaning}`})), SHAPES[0].name); 
            populateSelectWithOptions(chunkColorSelect, COLORS.map(c => ({value: c.name, text: `${c.symbol} ${c.name} - ${c.essence}`})), COLORS[0].name); 
        }

        function renderCustomTypesUI() {
            customTypesContainer.innerHTML = '';
            const allTypes = Object.values(chunkTypes).flat();
            allTypes.forEach(type => {
                const typeDiv = document.createElement('div');
                typeDiv.className = 'flex items-center justify-between text-sm p-1';
                typeDiv.innerHTML = `<span><span class="font-bold">${type.tag}</span>: ${type.description}</span>`;
                const isDefault = DEFAULT_CHUNK_TYPES.core.some(d => d.tag === type.tag) || DEFAULT_CHUNK_TYPES.secondary.some(d => d.tag === type.tag);
                if(!isDefault) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '&times;'; deleteBtn.className = 'ml-4 text-red-500 font-bold hover:text-red-700'; deleteBtn.title = 'Delete this type';
                    deleteBtn.onclick = () => {
                        showMessage(
                            "Confirm Delete",
                            `Are you sure you want to delete the chunk type "${type.tag}"? This cannot be undone.`,
                            [
                                { text: 'Cancel', class: 'btn-secondary' },
                                { text: 'Delete', class: 'btn-danger', action: () => {
                                    for (const group in chunkTypes) { 
                                        chunkTypes[group] = chunkTypes[group].filter(t => t.tag !== type.tag);
                                    }
                                    saveCustomChunkTypes();
                                }}
                            ]
                        );
                    };
                    typeDiv.appendChild(deleteBtn);
                }
                customTypesContainer.appendChild(typeDiv);
            });
        }
        
        // --- Custom Chunk Type Management ---
        function loadCustomChunkTypes() {
            try {
                const storedTypes = localStorage.getItem('chorusStrategistChunkTypes');
                if(storedTypes) {
                    chunkTypes = JSON.parse(storedTypes);
                } else {
                    chunkTypes = JSON.parse(JSON.stringify(DEFAULT_CHUNK_TYPES)); // Deep copy
                }
            } catch (e) {
                console.error("Could not load custom chunk types, reverting to default.", e);
                chunkTypes = JSON.parse(JSON.stringify(DEFAULT_CHUNK_TYPES));
            }
            allChunkTypesList = Object.values(chunkTypes).flat();
            renderCustomTypesUI();
            populateHelpModal();
        }
        function saveCustomChunkTypes() {
            try {
                localStorage.setItem('chorusStrategistChunkTypes', JSON.stringify(chunkTypes));
                 allChunkTypesList = Object.values(chunkTypes).flat();
                 renderCustomTypesUI(); // Rerender the list in settings
                 populateHelpModal();
                 populateAddChunkModal();
                 if (!editChunkModal.classList.contains('hidden')) {
                     const chunkId = editingChunkIdInput.value;
                     if(chunkId) openEditChunkModal(chunkId);
                 }
            } catch (e) { console.error("Could not save custom chunk types.", e); showMessage("Error", "Could not save custom chunk types to local storage."); }
        }
        
        // --- View Management (Canvas/Timeline) ---
        function toggleView() {
            currentView = (currentView === 'canvas') ? 'timeline' : 'canvas';
            if (currentView === 'timeline') {
                renderTimelineView();
                noteCanvasContainer.style.display = 'none';
                timelineView.style.display = 'block';
                viewToggleBtn.textContent = 'Canvas';
            } else {
                noteCanvasContainer.style.display = 'block';
                timelineView.style.display = 'none';
                viewToggleBtn.textContent = 'Timeline';
                applyTransform();
            }
        }
        
        function renderTimelineView() {
            timelineView.innerHTML = '';
            if (chunks.length === 0) {
                timelineView.innerHTML = '<p class="text-center text-gray-500">No chunks to display in timeline.</p>';
                return;
            }

            const renderedChunks = [];
            const visited = new Set();
            const MAX_INDENT = 3;

            // Calculate in-degrees (how many links point to a chunk)
            const inDegree = new Map(chunks.map(chunk => [chunk.id, 0]));
            chunks.forEach(chunk => {
                if (chunk.nextChunkIds) {
                    chunk.nextChunkIds.forEach(targetId => {
                        if (inDegree.has(targetId)) {
                            inDegree.set(targetId, inDegree.get(targetId) + 1);
                        }
                    });
                }
            });

            // Recursive function to traverse the graph and build the hierarchical list
            function traverse(chunkId, level) {
                if (!chunkId || visited.has(chunkId)) return;
                
                const chunk = chunksMap.get(chunkId);
                if (!chunk) return;

                visited.add(chunkId);
                renderedChunks.push({ chunk, level });

                if (chunk.nextChunkIds) {
                    chunk.nextChunkIds.forEach(nextId => {
                        traverse(nextId, Math.min(level + 1, MAX_INDENT));
                    });
                }
            }

            // Start traversal from root nodes (in-degree 0)
            const startNodes = chunks.filter(chunk => inDegree.get(chunk.id) === 0);
            startNodes.forEach(chunk => traverse(chunk.id, 0));

            // Traverse any remaining nodes (e.g., in cycles or disconnected graphs)
            chunks.forEach(chunk => {
                if (!visited.has(chunk.id)) {
                    traverse(chunk.id, 0);
                }
            });

            // Render the items with the calculated indentation
            renderedChunks.forEach(({ chunk, level }) => {
                const color = COLORS.find(c => c.name === chunk.colorName);
                const item = document.createElement('div');
                item.className = 'timeline-item';
                item.style.marginLeft = `${level * 2.5}rem`; 

                item.innerHTML = `
                    <div class="timeline-dot ${color?.tailwindClass.replace('text-', 'bg-') || 'bg-gray-500'}"></div>
                    <div class="timeline-content">
                        <div class="timeline-header">${chunk.chunkTypeTag}</div>
                        <div class="timeline-meta">${chunk.shapeSymbol || ''} ${chunk.shapeName} &bull; <span class="${color?.tailwindClass || ''}">${color?.symbol || ''} ${chunk.colorName}</span></div>
                        <div>${chunk.text}</div>
                    </div>
                `;
                timelineView.appendChild(item);
            });
        }


        // --- Layer Management ---
        function setupLayerControls() {
            layerControl.innerHTML = '';
            COLORS.forEach(color => {
                layerVisibility[color.name] = true;
                const label = document.createElement('label');
                label.innerHTML = `<input type="checkbox" data-color="${color.name}" checked> <span class="${color.tailwindClass}">${color.symbol}</span> ${color.name}`;
                layerControl.appendChild(label);
            });
            layerControl.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const colorName = e.target.dataset.color;
                    layerVisibility[colorName] = e.target.checked;
                    updateLayerVisibility();
                }
            });
        }
        function updateLayerVisibility() {
            chunks.forEach(chunk => {
                const isVisible = layerVisibility[chunk.colorName];
                const chunkEl = document.getElementById(chunk.id);
                if (chunkEl) { chunkEl.classList.toggle('hidden-by-layer', !isVisible); }
            });
            drawConnections();
        }

        // --- Template Management ---
        function setupTemplateModal() {
            templateList.innerHTML = '';
            for (const key in STRATEGIC_TEMPLATES) {
                const template = STRATEGIC_TEMPLATES[key];
                const btn = document.createElement('button');
                btn.className = 'btn btn-secondary w-full text-left justify-start';
                btn.innerHTML = `<div><div class="font-bold">${template.name}</div><div class="text-sm font-normal">${template.description}</div></div>`;
                btn.onclick = () => {
                    showMessage("Confirm Load Template", `This will clear the current canvas. Are you sure you want to load the "${template.name}" template?`, [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Load Template', class: 'btn-primary', action: () => { loadTemplate(key); hideModal(templatesModal); } } ]);
                };
                templateList.appendChild(btn);
            }
        }
        function loadTemplate(templateKey) {
            const template = STRATEGIC_TEMPLATES[templateKey];
            if (!template) return;

            renderBoard([]); // Clear the board first

            const loadedChunksData = [];
            const idMap = new Map();

            // First pass: create chunks and calculate bounding box of the template
            let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
            template.chunks.forEach(chunkTmpl => {
                minX = Math.min(minX, chunkTmpl.x);
                minY = Math.min(minY, chunkTmpl.y);
                maxX = Math.max(maxX, chunkTmpl.x + chunkTmpl.w);
                maxY = Math.max(maxY, chunkTmpl.y + chunkTmpl.h);
            });
            const templateWidth = maxX - minX;
            const templateHeight = maxY - minY;

            // Calculate the center of the viewport in world coordinates
            const viewportRect = noteCanvasContainer.getBoundingClientRect();
            const viewportCenterX = (viewportRect.width / 2);
            const viewportCenterY = (viewportRect.height / 2);
            const worldCenter = screenToWorld(viewportCenterX, viewportCenterY);

            // Calculate the offset needed to center the template
            const offsetX = worldCenter.x - (minX + templateWidth / 2);
            const offsetY = worldCenter.y - (minY + templateHeight / 2);

            // Second pass: create chunk data with the calculated offset
            template.chunks.forEach(chunkTmpl => {
                const chunkType = allChunkTypesList.find(ct => ct.tag === chunkTmpl.type);
                const shape = SHAPES.find(s => s.name === chunkTmpl.shape);
                const color = COLORS.find(c => c.name === chunkTmpl.color);
                if(!chunkType || !shape || !color) { console.warn("Skipping template chunk with invalid properties:", chunkTmpl); return; }
                const newId = generateId();
                if(chunkTmpl.id) idMap.set(chunkTmpl.id, newId);
                
                const newChunkData = {
                    id: newId,
                    chunkTypeTag: chunkTmpl.type,
                    shapeName: chunkTmpl.shape, shapeSymbol: shape.symbol,
                    colorName: chunkTmpl.color, colorSymbol: color.symbol, colorTailwindClass: color.tailwindClass,
                    text: chunkTmpl.text || '...',
                    x: chunkTmpl.x + offsetX,
                    y: chunkTmpl.y + offsetY,
                    width: chunkTmpl.w, height: chunkTmpl.h,
                    zIndex: ++highestZIndex,
                    nextChunkIds: [] // Initialize as array
                };
                loadedChunksData.push(newChunkData);
            });

            if (template.links) {
                template.links.forEach(link => {
                    const sourceId = idMap.get(link.from); const targetId = idMap.get(link.to);
                    const sourceChunk = loadedChunksData.find(c => c.id === sourceId);
                    if(sourceChunk && targetId) { sourceChunk.nextChunkIds.push(targetId); }
                });
            }
            
            renderBoard(loadedChunksData);
        }

        // --- Transform and Coordinate Functions ---
        function applyTransform() { if (!transformUpdateQueued) { transformUpdateQueued = true; requestAnimationFrame(() => { transformContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`; svgCanvas.setAttribute('width', String(noteCanvas.scrollWidth)); svgCanvas.setAttribute('height', String(noteCanvas.scrollHeight)); drawConnections(); transformUpdateQueued = false; }); } }
        function resetAndCenterView() { scale = 1; const viewportWidth = noteCanvasContainer.clientWidth; const viewportHeight = noteCanvasContainer.clientHeight; const canvasContentWidth = noteCanvas.scrollWidth; const canvasContentHeight = noteCanvas.scrollHeight; translateX = (viewportWidth - canvasContentWidth * scale) / 2; translateY = (viewportHeight - canvasContentHeight * scale) / 2; applyTransform(); }
        function screenToWorld(screenX, screenY) { const containerRect = noteCanvasContainer.getBoundingClientRect(); const rectLeft = containerRect.left || 0; const rectTop = containerRect.top || 0; const worldX = (screenX - rectLeft - translateX) / scale; const worldY = (screenY - rectTop - translateY) / scale; return { x: worldX, y: worldY }; }
        function getPointerCoordinates(e) { if (e.touches && e.touches.length > 0) { return { x: e.touches[0].clientX, y: e.touches[0].clientY, count: e.touches.length }; } return { x: e.clientX, y: e.clientY, count: e.buttons === 1 ? 1 : 0 }; }
        
        // --- Gemini AI Functions ---
        function loadApiKey() { const key = localStorage.getItem('geminiApiKey'); if (key) { geminiApiKey = key; geminiApiKeyInput.value = key; } }
        function saveApiKey() { const key = geminiApiKeyInput.value.trim(); if (key) { geminiApiKey = key; localStorage.setItem('geminiApiKey', key); showMessage("API Key Saved", "Your Gemini API key has been saved locally."); } else { localStorage.removeItem('geminiApiKey'); geminiApiKey = null; showMessage("API Key Cleared", "Your API key has been removed."); } }
        async function callGemini(prompt, buttonToLoad) { if (!geminiApiKey) { showMessage("API Key Required", "Please enter your Google AI API key in the Settings modal first.", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Open Settings', class: 'btn-primary', action: () => showModal(settingsModal) } ]); return null; } if (buttonToLoad) setButtonLoading(buttonToLoad, true); const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`; try { const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }), }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`); } const data = await response.json(); if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) { return data.candidates[0].content.parts[0].text; } else { if(data.candidates && data.candidates[0].finishReason === 'SAFETY') { throw new Error("The response was blocked due to safety settings. Please adjust your prompt."); } throw new Error("Received an empty or invalid response from the AI."); } } catch (error) { showMessage("AI Error", `An error occurred: ${error.message}`); console.error("Gemini API call failed:", error); return null; } finally { if (buttonToLoad) setButtonLoading(buttonToLoad, false); } }
        function openAiModal(chunkId) { if (!geminiApiKey) { showMessage("API Key Required", "Please enter your Google AI API key in the Settings modal first.", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Open Settings', class: 'btn-primary', action: () => showModal(settingsModal) } ]); return; } activeAiChunkId = chunkId; aiPromptTextarea.value = ''; showModal(aiActionModal); aiPromptTextarea.focus(); }
        async function summarizeBoard() { if (chunks.length === 0) { showMessage("Empty Board", "There's nothing on the board to summarize."); return; } const allText = getCombinedTextForExport('txt'); const prompt = `Please provide a concise, high-level summary of the following strategic notes. Distill the main objectives, key assets and threats, and overall strategic direction. NOTES:\n${allText}`; const summary = await callGemini(prompt, summarizeBtn); if (summary) { const formattedSummary = summary.replace(/\n/g, '<br>'); showMessage("Board Summary", formattedSummary); } }
        async function handleSuggestNextChunk() { const sourceChunkData = chunksMap.get(activeAiChunkId); if (!sourceChunkData) { showMessage("Error", "Could not find the source chunk to generate a suggestion from."); return; } const prompt = `Based on the following text from a strategic planning note, suggest the content for a new, subsequent note that logically follows it. The new note should be a natural continuation, a counter-point, or an expansion. Provide ONLY the text for the new note itself, without any introductory phrases. CONTEXT:\n${sourceChunkData.text}`; const newText = await callGemini(prompt, aiActionSuggestNextBtn); if (newText) { const newChunkDetails = { type: allChunkTypesList.find(ct => ct.tag === "#action") || allChunkTypesList[0], shape: SHAPES.find(s => s.name === "Square") || SHAPES[0], color: COLORS.find(c => c.name === "Grey") || COLORS[0], }; const newChunkOptions = { text: `<p>${newText.replace(/\n/g, '<br>')}</p>`, x: sourceChunkData.x + sourceChunkData.width + 40, y: sourceChunkData.y }; const newChunkData = addChunkToCanvas(newChunkDetails, newChunkOptions); if (!sourceChunkData.nextChunkIds.includes(newChunkData.id)) { sourceChunkData.nextChunkIds.push(newChunkData.id); } drawConnections(); updateSelectedVisuals(); hideModal(aiActionModal); showMessage("AI Suggestion", "A new chunk has been created and linked based on your previous note."); } }

        // --- Chunk Management & Selection ---
        function openEditChunkModal(chunkId) {
            const chunkData = chunksMap.get(chunkId);
            if (!chunkData) {
                showMessage("Error", "Could not find the chunk to edit.");
                return;
            }

            editingChunkIdInput.value = chunkId;

            populateSelectWithOptions(editChunkTypeSelect, null, chunkData.chunkTypeTag, chunkTypes, key => key.charAt(0).toUpperCase() + key.slice(1) + " Types");
            populateSelectWithOptions(editChunkShapeSelect, SHAPES.map(s => ({ value: s.name, text: `${s.symbol} ${s.name} - ${s.meaning}` })), chunkData.shapeName);
            populateSelectWithOptions(editChunkColorSelect, COLORS.map(c => ({ value: c.name, text: `${c.symbol} ${c.name} - ${c.essence}` })), chunkData.colorName);

            showModal(editChunkModal);
        }

        function updateChunkHeaderDisplay(chunkId) { const chunkElement = document.getElementById(chunkId); const chunkData = chunksMap.get(chunkId); if (!chunkElement || !chunkData) return; const headerTitle = chunkElement.querySelector('.chunk-header-title'); if (headerTitle) { const selectedShape = SHAPES.find(s => s.name === chunkData.shapeName); const selectedColor = COLORS.find(c => c.name === chunkData.colorName); headerTitle.innerHTML = `<span class="tag">${chunkData.chunkTypeTag}</span> | <span class="shape-symbol ${selectedColor?.tailwindClass || ''}">${selectedShape?.symbol || ''}</span> <span class="color-symbol ${selectedColor?.tailwindClass || ''}">${selectedColor?.symbol || ''}</span>`; } }
        function updateSelectedVisuals() { document.querySelectorAll('.chorus-chunk').forEach(el => { const chunkData = chunksMap.get(el.id); if (!chunkData) return; const isSelected = el.id === selectedChunkId; const isLinkingSource = el.id === linkingSourceChunkId; el.classList.toggle('selected-chunk', isSelected && !linkingMode); el.classList.toggle('linking-source-chunk', isLinkingSource && linkingMode); const linkButton = el.querySelector('.link-chunk-btn'); if (linkButton) { if (isLinkingSource && linkingMode) { linkButton.innerHTML = ICON_LINKING_ACTIVE; linkButton.title = 'Cancel Linking'; linkButton.classList.add('linking-active'); } else if (chunkData.nextChunkIds && chunkData.nextChunkIds.length > 0) { linkButton.innerHTML = ICON_UNLINK; linkButton.title = `Manage Links (${chunkData.nextChunkIds.length})`; linkButton.classList.remove('linking-active'); } else { linkButton.innerHTML = ICON_LINK; linkButton.title = 'Link to Next Chunk'; linkButton.classList.remove('linking-active'); } } }); }
        function selectChunk(chunkId) { selectedChunkId = chunkId; updateSelectedVisuals(); }
        function deselectAllChunks() { const wasLinking = linkingMode; if (wasLinking) { cancelLinkingMode(true); } selectedChunkId = null; if (!wasLinking) { updateSelectedVisuals(); } }
        function createChunkElement(chunkData) {
            const chunkDiv = document.createElement('div');
            chunkDiv.id = chunkData.id; chunkDiv.className = 'chorus-chunk';
            chunkDiv.style.left = chunkData.x + 'px'; chunkDiv.style.top = chunkData.y + 'px'; chunkDiv.style.width = chunkData.width + 'px'; chunkDiv.style.height = chunkData.height + 'px'; chunkDiv.style.zIndex = String(chunkData.zIndex);
            const isVisible = layerVisibility[chunkData.colorName];
            chunkDiv.classList.toggle('hidden-by-layer', !isVisible);
            chunkDiv.addEventListener('click', (e) => { const clickedChunkId = chunkData.id; if (linkingMode) { e.stopPropagation(); if (linkingSourceChunkId && linkingSourceChunkId !== clickedChunkId) { completeLink(linkingSourceChunkId, clickedChunkId); } else if (linkingSourceChunkId === clickedChunkId) { if (!e.target.closest('.chunk-action-btn')) { cancelLinkingMode(false); } } return; } const isInteractiveElement = e.target.closest('.chunk-action-btn') || e.target.closest('.chunk-content') || e.target.closest('.resize-handle'); if (!isInteractiveElement) { selectChunk(clickedChunkId); } });
            const header = document.createElement('div'); header.className = 'chunk-header'; header.addEventListener('mousedown', onInteractionStart); header.addEventListener('touchstart', onInteractionStart, { passive: false });
            const headerTitle = document.createElement('span'); headerTitle.className = 'chunk-header-title';
            const actionsContainer = document.createElement('div'); actionsContainer.className = 'chunk-actions';

            const aiBtn = document.createElement('button'); aiBtn.className = 'chunk-action-btn ai-chunk-btn'; aiBtn.title = 'AI Assistant'; aiBtn.innerHTML = ICON_AI_SPARKLE;
            const handleAiButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); openAiModal(chunkData.id); };
            aiBtn.addEventListener('click', handleAiButtonAction);
            aiBtn.addEventListener('touchend', handleAiButtonAction);
            
            const editBtn = document.createElement('button'); editBtn.className = 'chunk-action-btn edit-chunk-btn'; editBtn.title = 'Edit Chunk Properties'; editBtn.innerHTML = ICON_PENCIL_EDIT;
            const handleEditButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); openEditChunkModal(chunkData.id); };
            editBtn.addEventListener('click', handleEditButtonAction);
            editBtn.addEventListener('touchend', handleEditButtonAction);

            const linkBtn = document.createElement('button'); linkBtn.className = 'chunk-action-btn link-chunk-btn'; linkBtn.innerHTML = ICON_LINK;
            const handleLinkButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); const currentChunkData = chunksMap.get(chunkData.id); if (!currentChunkData) return; if (linkingMode && linkingSourceChunkId === currentChunkData.id) { cancelLinkingMode(false); } else if (currentChunkData.nextChunkIds && currentChunkData.nextChunkIds.length > 0) { openUnlinkModal(currentChunkData.id); } else { startLinkingMode(currentChunkData.id); } };
            linkBtn.addEventListener('click', handleLinkButtonAction);
            linkBtn.addEventListener('touchend', handleLinkButtonAction);

            const deleteBtn = document.createElement('button'); deleteBtn.className = 'chunk-action-btn delete-chunk-btn'; deleteBtn.title = 'Delete Chunk'; deleteBtn.innerHTML = ICON_DELETE;
            const handleDeleteButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); deleteChunk(chunkData.id); };
            deleteBtn.addEventListener('click', handleDeleteButtonAction);
            deleteBtn.addEventListener('touchend', handleDeleteButtonAction);

            actionsContainer.appendChild(aiBtn); actionsContainer.appendChild(editBtn); actionsContainer.appendChild(linkBtn); actionsContainer.appendChild(deleteBtn);
            header.appendChild(headerTitle); header.appendChild(actionsContainer);
            const content = document.createElement('div'); content.className = 'chunk-content'; content.contentEditable = true; content.innerHTML = chunkData.text;
            content.addEventListener('input', () => { const currentChunkData = chunksMap.get(chunkDiv.id); if (currentChunkData) currentChunkData.text = content.innerHTML; });
            content.addEventListener('focus', () => { highestZIndex++; chunkDiv.style.zIndex = String(highestZIndex); const currentChunkData = chunksMap.get(chunkDiv.id); if (currentChunkData) currentChunkData.zIndex = highestZIndex; if (!linkingMode) selectChunk(chunkData.id); });
            const resizeHandle = document.createElement('div'); resizeHandle.className = 'resize-handle'; resizeHandle.addEventListener('mousedown', onInteractionStart); resizeHandle.addEventListener('touchstart', onInteractionStart, { passive: false });
            chunkDiv.appendChild(header); chunkDiv.appendChild(content); chunkDiv.appendChild(resizeHandle);
            noteCanvas.appendChild(chunkDiv);
            updateChunkHeaderDisplay(chunkData.id); updateSelectedVisuals();
            return chunkDiv;
        }
        function deleteChunk(chunkId) {
            const chunkIndex = chunks.findIndex(c => c.id === chunkId);
            if (chunkIndex > -1) {
                lastDeletedChunk = JSON.parse(JSON.stringify(chunks[chunkIndex]));
                chunks.splice(chunkIndex, 1);
                chunksMap.delete(chunkId);
                chunks.forEach(c => {
                    if (c.nextChunkIds && c.nextChunkIds.includes(chunkId)) {
                        c.nextChunkIds = c.nextChunkIds.filter(id => id !== chunkId);
                    }
                });
                undoDeleteBtn.disabled = false;
            }
            if (selectedChunkId === chunkId) deselectAllChunks();
            if (linkingSourceChunkId === chunkId) cancelLinkingMode(false);
            const chunkElement = document.getElementById(chunkId);
            if (chunkElement) noteCanvas.removeChild(chunkElement);
            drawConnections();
            updateChunkCounter();
            updateSelectedVisuals();
        }
        function undoDeleteLastChunk() { if (lastDeletedChunk) { if (chunksMap.has(lastDeletedChunk.id)) { showMessage("Undo Failed", "A chunk with the same ID already exists. Cannot undo."); lastDeletedChunk = null; undoDeleteBtn.disabled = true; return; } chunks.push(lastDeletedChunk); chunksMap.set(lastDeletedChunk.id, lastDeletedChunk); createChunkElement(lastDeletedChunk); drawConnections(); selectChunk(lastDeletedChunk.id); lastDeletedChunk = null; undoDeleteBtn.disabled = true; showMessage("Undo Successful", "The last deleted chunk has been restored."); updateChunkCounter(); } else { showMessage("Nothing to Undo", "No chunk deletion to undo."); } }
        function addChunkToCanvas(chunkDetails, options = {}) { const viewportRect = noteCanvasContainer.getBoundingClientRect(); const defaultWorldPos = screenToWorld( (viewportRect.left || 0) + (viewportRect.width || window.innerWidth) / 2, (viewportRect.top || 0) + (viewportRect.height || window.innerHeight) / 4 ); const newChunkData = { id: generateId(), chunkTypeTag: chunkDetails.type.tag, shapeName: chunkDetails.shape.name, shapeSymbol: chunkDetails.shape.symbol, colorName: chunkDetails.color.name, colorSymbol: chunkDetails.color.symbol, colorTailwindClass: chunkDetails.color.tailwindClass, text: options.text || 'New chunk... Start typing!', x: options.x !== undefined ? options.x : Math.max(0, defaultWorldPos.x), y: options.y !== undefined ? options.y : Math.max(0, defaultWorldPos.y), width: options.width || 250, height: options.height || 150, zIndex: ++highestZIndex, nextChunkIds: [] }; chunks.push(newChunkData); chunksMap.set(newChunkData.id, newChunkData); createChunkElement(newChunkData); selectChunk(newChunkData.id); drawConnections(); updateChunkCounter(); return newChunkData; }

        // --- Linking Logic ---
        function startLinkingMode(sourceId) { linkingMode = true; linkingSourceChunkId = sourceId; document.body.classList.add('linking-mode'); selectedChunkId = sourceId; updateSelectedVisuals(); }
        function cancelLinkingMode(cancelledByDeselectAll = false) { linkingMode = false; const prevSourceId = linkingSourceChunkId; linkingSourceChunkId = null; document.body.classList.remove('linking-mode'); if (cancelledByDeselectAll) { selectedChunkId = null; } else if (prevSourceId) { selectChunk(prevSourceId); } updateSelectedVisuals(); }
        
        function completeLink(sourceId, targetId) {
            const sourceChunk = chunksMap.get(sourceId);
            if (sourceChunk && targetId) {
                // Prevent linking to self
                if (sourceId === targetId) return;

                if (!sourceChunk.nextChunkIds) {
                    sourceChunk.nextChunkIds = [];
                }
                // Add link if it doesn't exist already
                if (!sourceChunk.nextChunkIds.includes(targetId)) {
                    sourceChunk.nextChunkIds.push(targetId);
                }
            }
            // Keep linking mode active
            drawConnections();
            updateSelectedVisuals();
        }

        function getIntersectionPointWithRect(rect, internalPoint, externalPoint) { const p1 = internalPoint; const p2 = externalPoint; const dx = p2.x - p1.x; const dy = p2.y - p1.y; if (dx === 0 && dy === 0) return p1; let tMin = Infinity; let intersection = null; const rectRight = rect.x + rect.width; const rectBottom = rect.y + rect.height; if (dx !== 0) { const t = (rect.x - p1.x) / dx; if (t > 1e-6) { const y = p1.y + t * dy; if (y >= rect.y && y <= rectBottom) { if (t < tMin) { tMin = t; intersection = { x: rect.x, y: y }; } } } } if (dx !== 0) { const t = (rectRight - p1.x) / dx; if (t > 1e-6) { const y = p1.y + t * dy; if (y >= rect.y && y <= rectBottom) { if (t < tMin) { tMin = t; intersection = { x: rectRight, y: y }; } } } } if (dy !== 0) { const t = (rect.y - p1.y) / dy; if (t > 1e-6) { const x = p1.x + t * dx; if (x >= rect.x && x <= rectRight) { if (t < tMin) { tMin = t; intersection = { x: x, y: rect.y }; } } } } if (dy !== 0) { const t = (rectBottom - p1.y) / dy; if (t > 1e-6) { const x = p1.x + t * dx; if (x >= rect.x && x <= rectRight) { if (t < tMin) { tMin = t; intersection = { x: x, y: rectBottom }; } } } } return intersection || p1; }
        let svgDefsCreated = false;
        function ensureSvgDefs() { if (svgDefsCreated) return; const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs'); const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker'); marker.setAttribute('id', 'arrowhead'); marker.setAttribute('viewBox', '0 0 10 10'); marker.setAttribute('refX', '10'); marker.setAttribute('refY', '5'); marker.setAttribute('markerUnits', 'strokeWidth'); marker.setAttribute('markerWidth', '6'); marker.setAttribute('markerHeight', '5'); marker.setAttribute('orient', 'auto'); const path = document.createElementNS('http://www.w3.org/2000/svg', 'path'); path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); path.classList.add('arrow-head'); marker.appendChild(path); defs.appendChild(marker); svgCanvas.appendChild(defs); svgDefsCreated = true; }
        function drawConnections() { ensureSvgDefs(); const existingLines = svgCanvas.querySelectorAll('line'); existingLines.forEach(line => line.remove()); chunks.forEach(sourceChunkData => { if (sourceChunkData.nextChunkIds && sourceChunkData.nextChunkIds.length > 0) { sourceChunkData.nextChunkIds.forEach(targetId => { const targetChunkData = chunksMap.get(targetId); if (targetChunkData) { const sourceEl = document.getElementById(sourceChunkData.id); const targetEl = document.getElementById(targetId); if (sourceEl && targetEl) { const isSourceVisible = layerVisibility[sourceChunkData.colorName]; const isTargetVisible = layerVisibility[targetChunkData.colorName]; const sourceRect = { x: sourceEl.offsetLeft, y: sourceEl.offsetTop, width: sourceEl.offsetWidth, height: sourceEl.offsetHeight }; const targetRect = { x: targetEl.offsetLeft, y: targetEl.offsetTop, width: targetEl.offsetWidth, height: targetEl.offsetHeight }; const sourceCenter = { x: sourceRect.x + sourceRect.width / 2, y: sourceRect.y + sourceRect.height / 2 }; const targetCenter = { x: targetRect.x + targetRect.width / 2, y: targetRect.y + targetRect.height / 2 }; if (sourceCenter.x === targetCenter.x && sourceCenter.y === targetCenter.y) return; const startPoint = getIntersectionPointWithRect(sourceRect, sourceCenter, targetCenter); const endPoint = getIntersectionPointWithRect(targetRect, targetCenter, sourceCenter); const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.setAttribute('x1', String(startPoint.x)); line.setAttribute('y1', String(startPoint.y)); line.setAttribute('x2', String(endPoint.x)); line.setAttribute('y2', String(endPoint.y)); line.classList.add('connecting-line'); line.setAttribute('marker-end', 'url(#arrowhead)'); line.classList.toggle('hidden-by-layer', !isSourceVisible || !isTargetVisible); svgCanvas.appendChild(line); } } }); } }); }
        
        // --- Unlink Modal Logic ---
        function openUnlinkModal(sourceId) {
            const sourceChunk = chunksMap.get(sourceId);
            if (!sourceChunk || !sourceChunk.nextChunkIds || sourceChunk.nextChunkIds.length === 0) {
                return;
            }
            unlinkList.innerHTML = ''; // Clear previous list
            sourceChunk.nextChunkIds.forEach(targetId => {
                const targetChunk = chunksMap.get(targetId);
                if (targetChunk) {
                    const item = document.createElement('div');
                    item.className = 'flex justify-between items-center p-2 hover:bg-gray-100 rounded-md';
                    item.innerHTML = `<span>${targetChunk.chunkTypeTag}</span>`;
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'btn btn-danger btn-sm !m-0';
                    removeBtn.textContent = 'Remove';
                    removeBtn.onclick = () => {
                        sourceChunk.nextChunkIds = sourceChunk.nextChunkIds.filter(id => id !== targetId);
                        item.remove(); // Remove from modal list
                        drawConnections();
                        updateSelectedVisuals();
                        if (sourceChunk.nextChunkIds.length === 0) {
                            hideModal(unlinkModal);
                        }
                    };
                    item.appendChild(removeBtn);
                    unlinkList.appendChild(item);
                }
            });
            showModal(unlinkModal);
        }


        // --- Interaction Logic (Drag, Resize, Pan, Zoom) ---
        function onInteractionStart(e) {
            if (linkingMode) return;

            const isTouchEvent = e.type.startsWith('touch');
            if (isTouchEvent && e.touches.length > 1) return;
            if (isTouchEvent) e.preventDefault();
            const pointer = getPointerCoordinates(e);
            interactionStartX = pointer.x;
            interactionStartY = pointer.y;
            if (e.target.classList.contains('resize-handle')) {
                currentAction = 'resize';
                resizingChunk = e.target.closest('.chorus-chunk');
                if (!resizingChunk) { currentAction = null; return; }
                e.stopPropagation();
                selectChunk(resizingChunk.id);
                highestZIndex++;
                resizingChunk.style.zIndex = String(highestZIndex);
                const chunkData = chunksMap.get(resizingChunk.id);
                if(chunkData) chunkData.zIndex = highestZIndex;
                startX = pointer.x;
                startY = pointer.y;
                startWidth = parseFloat(resizingChunk.style.width);
                startHeight = parseFloat(resizingChunk.style.height);
            } else if (e.target.closest('.chunk-header')) {
                if (e.target.closest('.chunk-action-btn')) return;
                currentAction = 'drag';
                draggedChunk = e.target.closest('.chorus-chunk');
                if (!draggedChunk) { currentAction = null; return; }
                e.stopPropagation();
                selectChunk(draggedChunk.id);
                highestZIndex++;
                draggedChunk.style.zIndex = String(highestZIndex);
                const chunkData = chunksMap.get(draggedChunk.id);
                if(chunkData) chunkData.zIndex = highestZIndex;
                const worldPointer = screenToWorld(pointer.x, pointer.y);
                offsetX = worldPointer.x - parseFloat(draggedChunk.style.left);
                offsetY = worldPointer.y - parseFloat(draggedChunk.style.top);
            }
            if (currentAction === 'drag' || currentAction === 'resize') {
                document.addEventListener('mousemove', onInteractionMove);
                document.addEventListener('mouseup', onInteractionEnd);
                document.addEventListener('touchmove', onInteractionMove, { passive: false });
                document.addEventListener('touchend', onInteractionEnd);
            }
        }
        let interactionMoveQueued = false;
        function onInteractionMove(e) { const isTouchEvent = e.type.startsWith('touch'); if (!currentAction) return; if (isTouchEvent) e.preventDefault(); if (interactionMoveQueued) return; interactionMoveQueued = true; requestAnimationFrame(() => { const pointer = getPointerCoordinates(e); if (currentAction === 'drag' && draggedChunk) { const worldPointer = screenToWorld(pointer.x, pointer.y); let newWorldX = worldPointer.x - offsetX; let newWorldY = worldPointer.y - offsetY; const canvasWorldWidth = noteCanvas.scrollWidth; const canvasWorldHeight = noteCanvas.scrollHeight; const chunkWidth = parseFloat(draggedChunk.style.width); const chunkHeight = parseFloat(draggedChunk.style.height); newWorldX = Math.max(0, Math.min(newWorldX, canvasWorldWidth - chunkWidth)); newWorldY = Math.max(0, Math.min(newWorldY, canvasWorldHeight - chunkHeight)); draggedChunk.style.left = newWorldX + 'px'; draggedChunk.style.top = newWorldY + 'px'; drawConnections(); } else if (currentAction === 'resize' && resizingChunk) { const deltaScreenX = pointer.x - startX; const deltaScreenY = pointer.y - startY; let newWidth = startWidth + (deltaScreenX / scale); let newHeight = startHeight + (deltaScreenY / scale); newWidth = Math.max(100, newWidth); newHeight = Math.max(80, newHeight); const chunkCurrentX = parseFloat(resizingChunk.style.left); const chunkCurrentY = parseFloat(resizingChunk.style.top); const canvasWorldWidth = noteCanvas.scrollWidth; const canvasWorldHeight = noteCanvas.scrollHeight; if (chunkCurrentX + newWidth > canvasWorldWidth) newWidth = canvasWorldWidth - chunkCurrentX; if (chunkCurrentY + newHeight > canvasWorldHeight) newHeight = canvasWorldHeight - chunkCurrentY; resizingChunk.style.width = newWidth + 'px'; resizingChunk.style.height = newHeight + 'px'; drawConnections(); } else if (currentAction === 'pan') { translateX = pointer.x - panStartX; translateY = pointer.y - panStartY; applyTransform(); } interactionMoveQueued = false; }); }
        function onInteractionEnd(e) { if (currentAction === 'drag' && draggedChunk) { const chunkData = chunksMap.get(draggedChunk.id); if (chunkData) { chunkData.x = parseFloat(draggedChunk.style.left); chunkData.y = parseFloat(draggedChunk.style.top); } draggedChunk = null; } else if (currentAction === 'resize' && resizingChunk) { const chunkData = chunksMap.get(resizingChunk.id); if (chunkData) { chunkData.width = parseFloat(resizingChunk.style.width); chunkData.height = parseFloat(resizingChunk.style.height); } resizingChunk = null; } else if (currentAction === 'pan') { noteCanvasContainer.classList.remove('panning'); } if (currentAction !== 'pinch-zoom') { currentAction = null; } document.removeEventListener('mousemove', onInteractionMove); document.removeEventListener('mouseup', onInteractionEnd); document.removeEventListener('touchmove', onInteractionMove); document.removeEventListener('touchend', onInteractionEnd); }
        
        // --- Save/Load & Export ---
        function getCombinedTextForExport(format) {
            const tempDiv = document.createElement('div');
            
            function cleanText(html) {
                tempDiv.innerHTML = html;
                return tempDiv.textContent || tempDiv.innerText || "";
            }

            let output = "";
            let visited = new Set();
            const allChunkIds = new Set(chunks.map(c => c.id));
            const targetIds = new Set(chunks.flatMap(c => c.nextChunkIds || []));
            const startNodes = chunks.filter(c => !targetIds.has(c.id));
             // Add any orphaned cycles
            chunks.forEach(c => {
                if(!visited.has(c.id) && !startNodes.some(sn => sn.id === c.id)) {
                    startNodes.push(c);
                }
            });


            function traverse(chunkId, prefix = "", isLast = true) {
                if (!chunkId || visited.has(chunkId)) return;
                
                const chunk = chunksMap.get(chunkId);
                if (!chunk) return;
                
                visited.add(chunkId);
                
                const textContent = cleanText(chunk.text).trim();
                const links = chunk.nextChunkIds && chunk.nextChunkIds.length > 0
                    ? chunk.nextChunkIds.map(id => chunksMap.get(id)?.chunkTypeTag || "unknown").join(', ')
                    : "None";

                switch (format) {
                    case 'txt':
                        output += `${prefix}${chunk.chunkTypeTag} (${chunk.shapeName} / ${chunk.colorName})\n`;
                        output += `${prefix}${textContent}\n`;
                        output += `${prefix}  -> Links to: ${links}\n\n`;
                        break;
                    case 'md':
                        output += `${prefix}## ${chunk.chunkTypeTag}\n`;
                        output += `${prefix}*${chunk.shapeName} / ${chunk.colorName}*\n\n`;
                        output += `${prefix}${textContent.replace(/\n/g, `\n${prefix}`)}\n\n`;
                        if (links !== "None") {
                            output += `${prefix}**Links to:** ${links}\n\n`;
                        }
                        output += `${prefix}---\n\n`;
                        break;
                    case 'html':
                        output += `<div class="chunk" style="margin-left: ${prefix.length * 10}px;"><h3>${chunk.chunkTypeTag}</h3><div class="meta">${chunk.shapeName} &bull; ${chunk.colorName}</div><div>${chunk.text}</div>`;
                        if (links !== "None") {
                            output += `<div class="links"><strong>Links to:</strong> ${links}</div>`;
                        }
                        output += `</div>`;
                        break;
                }
                
                if (chunk.nextChunkIds && chunk.nextChunkIds.length > 0) {
                    const lastIndex = chunk.nextChunkIds.length - 1;
                    chunk.nextChunkIds.forEach((nextId, index) => {
                        traverse(nextId, prefix + "    ", index === lastIndex);
                    });
                }
            }

            startNodes.forEach(node => traverse(node.id));

            // Add any remaining orphaned nodes not caught in start nodes
            chunks.forEach(chunk => {
                if (!visited.has(chunk.id)) {
                     traverse(chunk.id);
                }
            });

            return output;
        }

        function saveDataToFile() { chunks.forEach(chunkData => { const chunkElement = document.getElementById(chunkData.id); if (chunkElement) { const contentDiv = chunkElement.querySelector('.chunk-content'); if (contentDiv) { chunkData.text = contentDiv.innerHTML; } } }); if (chunks.length === 0) { showMessage("Empty Board", "There are no notes to save."); return; } setButtonLoading(saveBtn, true); try { const dataToSave = { chunks: chunks, viewport: { scale: scale, translateX: translateX, translateY: translateY } }; const dataStr = JSON.stringify(dataToSave, null, 2); downloadFile(dataStr, 'chorus-strategist-map.json', 'application/json'); showMessage('Saved to File', 'Your board has been prepared for download.'); } catch (error) { showMessage('Save Error', `Could not prepare data for saving: ${error.message}`); console.error("Save error:", error); } finally { setButtonLoading(saveBtn, false); } }
        function downloadFile(content, fileName, contentType) { const a = document.createElement('a'); const file = new Blob([content], {type: contentType}); a.href = URL.createObjectURL(file); a.download = fileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href); }
        function renderBoard(loadedChunksData) {
            const existingChunkElements = noteCanvas.querySelectorAll('.chorus-chunk'); existingChunkElements.forEach(el => el.remove());
            chunks = loadedChunksData || []; chunksMap.clear(); highestZIndex = 0; selectedChunkId = null; lastDeletedChunk = null; undoDeleteBtn.disabled = true; cancelLinkingMode(true);
            if (Array.isArray(chunks)) { chunks.forEach(chunkData => { chunkData.nextChunkIds = chunkData.nextChunkIds || []; if (chunkData && chunkData.id && chunkData.chunkTypeTag && chunkData.shapeName && chunkData.colorName) { chunksMap.set(chunkData.id, chunkData); createChunkElement(chunkData); if (chunkData.zIndex > highestZIndex) { highestZIndex = chunkData.zIndex; } } else { console.warn("Skipping invalid chunk data during render:", chunkData); } }); }
            if(chunks.length === 0) highestZIndex = 1;
            updateSelectedVisuals(); drawConnections(); updateChunkCounter(); updateLayerVisibility();
        }

        const originalButtonStates = {};
        function setButtonLoading(button, isLoading) { if (!button) { return; } const buttonId = button.id || `btn-${Math.random()}`; button.id = buttonId; if (isLoading) { if (!originalButtonStates[buttonId]) { originalButtonStates[buttonId] = button.innerHTML; } button.innerHTML = `<svg class="animate-spin h-5 w-5 spinner" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`; button.classList.add('loading'); button.disabled = true; } else { if (originalButtonStates[buttonId] !== undefined) { button.innerHTML = originalButtonStates[buttonId]; delete originalButtonStates[buttonId]; } button.classList.remove('loading'); button.disabled = false; } }

        function setupDropdowns() {
            const dropdowns = document.querySelectorAll('.dropdown');

            dropdowns.forEach(dropdown => {
                const trigger = dropdown.querySelector('button');
                const content = dropdown.querySelector('.dropdown-content');
                
                trigger.addEventListener('click', (event) => {
                    event.stopPropagation();
                    document.querySelectorAll('.dropdown-content.show').forEach(openContent => {
                        if (openContent !== content) {
                            openContent.classList.remove('show');
                        }
                    });
                    content.classList.toggle('show');
                });

                content.addEventListener('click', (event) => {
                    event.stopPropagation();
                });
            });

            window.addEventListener('click', () => {
                document.querySelectorAll('.dropdown-content.show').forEach(openContent => {
                    openContent.classList.remove('show');
                });
            });
        }


        // --- Initialization Sequence ---
        function initializeApp() {
            document.getElementById('copyrightYear').textContent = new Date().getFullYear();
            
            // Load data and setup UI elements
            loadApiKey(); 
            loadCustomChunkTypes(); 
            setupLayerControls(); 
            setupTemplateModal(); 
            populateAddChunkModal();
            setupDropdowns();
            
            // Render the initial empty board
            renderBoard([]);
            
            // Add all event listeners
            // Toolbar
            addChunkBtn.addEventListener('click', () => { if(linkingMode) cancelLinkingMode(false); showModal(addChunkModal); });
            templatesBtn.addEventListener('click', () => showModal(templatesModal));
            clearCanvasBtn.addEventListener('click', () => { if (linkingMode) cancelLinkingMode(false); if (chunks.length === 0) { showMessage("Canvas Empty", "The canvas is already clear."); return; } showMessage("Confirm Clear", "Are you sure you want to clear the entire canvas? This action cannot be undone.", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Clear Canvas', class: 'btn-danger', action: () => { renderBoard([]); showMessage("Canvas Cleared", "All notes and links have been removed."); }} ]); });
            undoDeleteBtn.addEventListener('click', () => { if (linkingMode) cancelLinkingMode(false); undoDeleteLastChunk(); });
            summarizeBtn.addEventListener('click', summarizeBoard);
            viewToggleBtn.addEventListener('click', toggleView);
            
            // ZOOM FIX: Implement consistent centered zoom logic for buttons
            zoomInBtn.addEventListener('click', () => {
                const rect = noteCanvasContainer.getBoundingClientRect();
                const centerXRelative = rect.width / 2;
                const centerYRelative = rect.height / 2;
                const worldXBeforeZoom = (centerXRelative - translateX) / scale;
                const worldYBeforeZoom = (centerYRelative - translateY) / scale;
                let newScale = Math.min(MAX_SCALE, scale * 1.25);
                translateX = centerXRelative - worldXBeforeZoom * newScale;
                translateY = centerYRelative - worldYBeforeZoom * newScale;
                scale = newScale;
                applyTransform();
            });
            zoomOutBtn.addEventListener('click', () => {
                const rect = noteCanvasContainer.getBoundingClientRect();
                const centerXRelative = rect.width / 2;
                const centerYRelative = rect.height / 2;
                const worldXBeforeZoom = (centerXRelative - translateX) / scale;
                const worldYBeforeZoom = (centerYRelative - translateY) / scale;
                let newScale = Math.max(MIN_SCALE, scale / 1.25);
                translateX = centerXRelative - worldXBeforeZoom * newScale;
                translateY = centerYRelative - worldYBeforeZoom * newScale;
                scale = newScale;
                applyTransform();
            });

            zoomResetBtn.addEventListener('click', resetAndCenterView);
            saveBtn.addEventListener('click', saveDataToFile);
            loadBtn.addEventListener('click', () => { if(linkingMode) cancelLinkingMode(false); if (chunks.length > 0) { showMessage("Confirm Load", "Loading a new file will clear any unsaved changes on the current canvas. Are you sure you want to proceed?", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Load File', class: 'btn-primary', action: () => fileLoadInput.click() } ]); } else { fileLoadInput.click(); } });
            settingsBtn.addEventListener('click', () => showModal(settingsModal));
            helpBtn.addEventListener('click', () => { if(linkingMode) cancelLinkingMode(false); showModal(helpModal); });
            donateBtn.addEventListener('click', () => window.open('https://ko-fi.com/thorstenbecker', '_blank', 'noopener,noreferrer'));
            exportTxtBtn.addEventListener('click', () => {
                downloadFile(getCombinedTextForExport('txt'), 'chorus-export.txt', 'text/plain');
                document.querySelectorAll('.dropdown-content.show').forEach(openContent => openContent.classList.remove('show'));
            });
            exportMdBtn.addEventListener('click', () => {
                downloadFile(getCombinedTextForExport('md'), 'chorus-export.md', 'text/markdown');
                document.querySelectorAll('.dropdown-content.show').forEach(openContent => openContent.classList.remove('show'));
            });
            exportHtmlBtn.addEventListener('click', () => {
                const content = `<html><head><title>CHORUS Export</title><style>.chunk{border:1px solid #ccc;padding:10px;margin-bottom:10px;border-radius:5px;}.meta{font-size:0.8em;color:gray;}</style></head><body>${getCombinedTextForExport('html')}</body></html>`;
                downloadFile(content, 'chorus-export.html', 'text/html');
                document.querySelectorAll('.dropdown-content.show').forEach(openContent => openContent.classList.remove('show'));
            });


            // Modals
            cancelAddChunkBtn.addEventListener('click', () => hideModal(addChunkModal));
            confirmAddChunkBtn.addEventListener('click', () => { const selectedType = allChunkTypesList.find(ct => ct.tag === chunkTypeSelect.value); const selectedShape = SHAPES.find(s => s.name === chunkShapeSelect.value); const selectedColor = COLORS.find(c => c.name === chunkColorSelect.value); if (!selectedType || !selectedShape || !selectedColor) { showMessage('Error', 'Please make a selection for all properties.'); return; } addChunkToCanvas({ type: selectedType, shape: selectedShape, color: selectedColor }); hideModal(addChunkModal); });
            cancelEditChunkBtn.addEventListener('click', () => hideModal(editChunkModal));
            confirmEditChunkBtn.addEventListener('click', () => { const chunkId = editingChunkIdInput.value; const chunkData = chunksMap.get(chunkId); if (!chunkData) return; const newType = allChunkTypesList.find(ct => ct.tag === editChunkTypeSelect.value); const newShape = SHAPES.find(s => s.name === editChunkShapeSelect.value); const newColor = COLORS.find(c => c.name === editChunkColorSelect.value); if (!newType || !newShape || !newColor) { showMessage('Error', 'Invalid selection.'); return; } chunkData.chunkTypeTag = newType.tag; chunkData.shapeName = newShape.name; chunkData.shapeSymbol = newShape.symbol; chunkData.colorName = newColor.name; chunkData.colorSymbol = newColor.symbol; chunkData.colorTailwindClass = newColor.tailwindClass; updateChunkHeaderDisplay(chunkId); hideModal(editChunkModal); updateSelectedVisuals(); updateLayerVisibility(); });
            cancelSettingsBtn.addEventListener('click', () => hideModal(settingsModal));
            closeSettingsModalBtn.addEventListener('click', () => hideModal(settingsModal));
            saveSettingsBtn.addEventListener('click', () => { saveApiKey(); saveCustomChunkTypes(); hideModal(settingsModal); });
            addCustomTypeForm.addEventListener('submit', (e) => { e.preventDefault(); const tag = customTypeTagInput.value.trim(); const desc = customTypeDescInput.value.trim(); if (!tag.startsWith('#') || tag.length < 2 || !desc) { showMessage("Invalid Input", "Custom types must start with # and have a description."); return; } if(allChunkTypesList.some(t => t.tag === tag)){ showMessage("Duplicate Tag", "A chunk type with this tag already exists."); return; } if(!chunkTypes.custom) chunkTypes.custom = []; chunkTypes.custom.push({ tag, description: desc }); saveCustomChunkTypes(); customTypeTagInput.value = ''; customTypeDescInput.value = ''; });
            cancelAiActionBtn.addEventListener('click', () => hideModal(aiActionModal));
            closeAiActionModalBtn.addEventListener('click', () => hideModal(aiActionModal));
            aiActionSuggestNextBtn.addEventListener('click', handleSuggestNextChunk);
            aiActionGenerateBtn.addEventListener('click', async () => { const promptText = aiPromptTextarea.value.trim(); if (!promptText) { showMessage("Prompt Required", "Please enter a prompt for the AI."); return; } const chunkData = chunksMap.get(activeAiChunkId); if (!chunkData) { showMessage("Error", "Could not find the active chunk."); return; } const contentDiv = document.getElementById(activeAiChunkId)?.querySelector('.chunk-content'); if(!contentDiv) return; const fullPrompt = `CONTEXT:\n${contentDiv.innerText}\n\nPROMPT:\n${promptText}\n\nINSTRUCTIONS: Respond with only the generated text, without any introductory phrases or markdown.`; const result = await callGemini(fullPrompt, aiActionGenerateBtn); if (result !== null) { let htmlResult = result.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>'); htmlResult = `<p>${htmlResult}</p>`; contentDiv.innerHTML = htmlResult; chunkData.text = htmlResult; hideModal(aiActionModal); showMessage("Content Updated", "The chunk content has been updated by the AI."); } });
            closeHelpBtn.addEventListener('click', () => hideModal(helpModal));
            closeHelpModalSpan.addEventListener('click', () => hideModal(helpModal));
            closeUnlinkModalBtn.addEventListener('click', () => hideModal(unlinkModal));
            fileLoadInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (!file) return; if (file.type !== "application/json") { showMessage("Load Error", "Invalid file type. Please select a .json file."); event.target.value = null; return; } setButtonLoading(loadBtn, true); const reader = new FileReader(); reader.onload = (e) => { try { const loadedData = JSON.parse(e.target.result); if (loadedData && Array.isArray(loadedData.chunks)) { renderBoard(loadedData.chunks); if (loadedData.viewport) { scale = loadedData.viewport.scale || 1; translateX = loadedData.viewport.translateX || 0; translateY = loadedData.viewport.translateY || 0; applyTransform(); } else { resetAndCenterView(); } showMessage('Loaded from File', `Successfully loaded notes from ${file.name}.`); } else { throw new Error("Invalid file format. Expected 'chunks' array."); } } catch (error) { showMessage('Load Error', `Could not load or parse file: ${error.message}.`); console.error("Load error:", error); } finally { event.target.value = null; setButtonLoading(loadBtn, false); } }; reader.onerror = () => { showMessage('Load Error', `Error reading file: ${reader.error}`); event.target.value = null; setButtonLoading(loadBtn, false); console.error("File read error:", reader.error); }; reader.readAsText(file); });
            
            // Canvas and keyboard listeners
            noteCanvasContainer.addEventListener('mousedown', (e) => { if (e.target === noteCanvasContainer || e.target === transformContainer || e.target === noteCanvas) { if (linkingMode) { deselectAllChunks(); return; } currentAction = 'pan'; const pointer = getPointerCoordinates(e); panStartX = pointer.x - translateX; panStartY = pointer.y - translateY; noteCanvasContainer.classList.add('panning'); document.addEventListener('mousemove', onInteractionMove); document.addEventListener('mouseup', onInteractionEnd); } else if (!e.target.closest('.chorus-chunk') && !e.target.closest('.toolbar') && !e.target.closest('.modal')) { deselectAllChunks(); } });
            noteCanvasContainer.addEventListener('touchstart', (e) => { if (e.target === noteCanvasContainer || e.target === transformContainer || e.target === noteCanvas) { if (e.touches.length === 1) { if (linkingMode) { deselectAllChunks(); e.preventDefault(); return; } e.preventDefault(); currentAction = 'pan'; const pointer = getPointerCoordinates(e); panStartX = pointer.x - translateX; panStartY = pointer.y - translateY; noteCanvasContainer.classList.add('panning'); document.addEventListener('touchmove', onInteractionMove, { passive: false }); document.addEventListener('touchend', onInteractionEnd); } else if (e.touches.length === 2) { e.preventDefault(); currentAction = 'pinch-zoom'; noteCanvasContainer.classList.remove('panning'); const t1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }; const t2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }; initialPinchDistance = Math.hypot(t1.x - t2.x, t1.y - t2.y); } }  else if (!e.target.closest('.chorus-chunk') && !e.target.closest('.toolbar') && !e.target.closest('.modal')) { deselectAllChunks(); e.preventDefault(); } }, { passive: false });
            noteCanvasContainer.addEventListener('wheel', (e) => { e.preventDefault(); const rect = noteCanvasContainer.getBoundingClientRect(); const mouseX = e.clientX - (rect.left || 0); const mouseY = e.clientY - (rect.top || 0); const worldXBeforeZoom = (mouseX - translateX) / scale; const worldYBeforeZoom = (mouseY - translateY) / scale; const delta = e.deltaY * ZOOM_SENSITIVITY * -1; let newScale = scale * (1 + delta); newScale = Math.max(MIN_SCALE, Math.min(newScale, MAX_SCALE)); translateX = mouseX - worldXBeforeZoom * newScale; translateY = mouseY - worldYBeforeZoom * newScale; scale = newScale; applyTransform(); }, { passive: false });
            noteCanvasContainer.addEventListener('touchmove', (e) => { if (currentAction === 'pinch-zoom' && e.touches.length === 2) { e.preventDefault(); const t1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }; const t2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }; const currentPinchDistance = Math.hypot(t1.x - t2.x, t1.y - t2.y); const pinchMidpointScreen = { x: (t1.x + t2.x) / 2, y: (t1.y + t2.y) / 2 }; if (initialPinchDistance === null) { initialPinchDistance = currentPinchDistance; return; } const rect = noteCanvasContainer.getBoundingClientRect(); const worldMidXBeforeZoom = (pinchMidpointScreen.x - (rect.left || 0) - translateX) / scale; const worldMidYBeforeZoom = (pinchMidpointScreen.y - (rect.top || 0) - translateY) / scale; let scaleChange = currentPinchDistance / initialPinchDistance; let newScale = scale * scaleChange; newScale = Math.max(MIN_SCALE, Math.min(newScale, MAX_SCALE)); translateX = (pinchMidpointScreen.x - (rect.left || 0)) - worldMidXBeforeZoom * newScale; translateY = (pinchMidpointScreen.y - (rect.top || 0)) - worldMidYBeforeZoom * newScale; scale = newScale; applyTransform(); initialPinchDistance = currentPinchDistance; } }, { passive: false });
            noteCanvasContainer.addEventListener('touchend', (e) => { if (e.touches.length < 2 && currentAction === 'pinch-zoom') { initialPinchDistance = null; currentAction = null; } });
            document.addEventListener('keydown', (e) => { const activeEl = document.activeElement; const isInputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable); const isCtrlOrCmd = e.ctrlKey || e.metaKey; let shortcutHandled = false; if (isCtrlOrCmd) { switch (e.key.toLowerCase()) { case 's': saveBtn.click(); shortcutHandled = true; break; case 'o': loadBtn.click(); shortcutHandled = true; break; case 'z': if (!undoDeleteBtn.disabled) { undoDeleteBtn.click(); shortcutHandled = true; } break; } } if(shortcutHandled){ e.preventDefault(); return; } if (isInputFocused) { if (e.key === 'Escape') { activeEl.blur(); } return; } switch(e.key){ case 'Escape': if (!addChunkModal.classList.contains('hidden')) { hideModal(addChunkModal); } else if (!editChunkModal.classList.contains('hidden')) { hideModal(editChunkModal); } else if (!helpModal.classList.contains('hidden')) { hideModal(helpModal); } else if (!messageModal.classList.contains('hidden')) { hideModal(messageModal); } else if (!aiActionModal.classList.contains('hidden')) { hideModal(aiActionModal); } else if (!settingsModal.classList.contains('hidden')) { hideModal(settingsModal); } else if (linkingMode) { cancelLinkingMode(false); } else if (selectedChunkId) { deselectAllChunks(); } shortcutHandled = true; break; case 'Delete': case 'Backspace': if (selectedChunkId) { showMessage("Confirm Delete", `Are you sure you want to delete the selected chunk (${chunksMap.get(selectedChunkId)?.chunkTypeTag || 'chunk'})?`, [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Delete', class: 'btn-danger', action: () => { deleteChunk(selectedChunkId); }} ]); shortcutHandled = true; } break; case 'a': case 'A': addChunkBtn.click(); shortcutHandled = true; break; case '+': case '=': zoomInBtn.click(); shortcutHandled = true; break; case '-': zoomOutBtn.click(); shortcutHandled = true; break; case '0': zoomResetBtn.click(); shortcutHandled = true; break; case '?': case '/': helpBtn.click(); shortcutHandled = true; break; } if(shortcutHandled){ e.preventDefault(); } });

            // Final setup
            let resizeQueued = false;
            window.addEventListener('resize', () => { if (resizeQueued) return; resizeQueued = true; requestAnimationFrame(() => { const toolbarElement = document.querySelector('.toolbar'); const footerElement = document.querySelector('footer'); let toolbarHeight = toolbarElement ? toolbarElement.offsetHeight : 0; let footerHeight = footerElement ? footerElement.offsetHeight : 0; if (mainContent) { mainContent.style.height = `calc(100vh - ${toolbarHeight}px - ${footerHeight}px)`; } applyTransform(); resizeQueued = false; }); });
            window.dispatchEvent(new Event('resize'));
            resetAndCenterView();
            window.addEventListener('beforeunload', (event) => { if (chunks.length > 0) { event.preventDefault(); event.returnValue = ''; return ''; } });
            setTimeout(() => { document.getElementById('noteCanvasContainer').focus(); }, 100);
            
            console.log("CHORUS AI: Strategist's Edition Initialized");
        }
        initializeApp();
    });
    </script>
</body>
</html>
